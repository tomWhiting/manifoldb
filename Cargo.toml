[workspace]
resolver = "2"
members = [
    "crates/manifoldb",
    "crates/manifoldb-core",
    "crates/manifoldb-storage",
    "crates/manifoldb-graph",
    "crates/manifoldb-vector",
    "crates/manifoldb-query",
    "crates/manifold-server",
    "tools/manifold-cli",
    "tools/session-viewer/server",
]

[workspace.package]
version = "0.1.4"
edition = "2021"
authors = ["ManifoldDB Contributors"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/tomWhiting/manifoldb"
homepage = "https://github.com/tomWhiting/manifoldb"
documentation = "https://docs.rs/manifoldb"
rust-version = "1.75"
keywords = ["database", "graph", "vector", "embedded", "sql"]
categories = ["database", "data-structures"]

[workspace.dependencies]
# Internal crates - path for local dev, version for crates.io
manifoldb = { version = "0.1.4", path = "crates/manifoldb" }
manifoldb-core = { version = "0.1.4", path = "crates/manifoldb-core" }
manifoldb-storage = { version = "0.1.4", path = "crates/manifoldb-storage" }
manifoldb-graph = { version = "0.1.4", path = "crates/manifoldb-graph" }
manifoldb-vector = { version = "0.1.4", path = "crates/manifoldb-vector" }
manifoldb-query = { version = "0.1.4", path = "crates/manifoldb-query" }

# Storage
redb = "3.1"

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"
bincode = { version = "2", features = ["serde"] }
base64 = "0.22"

# Error handling
thiserror = "2"

# Parallelism
rayon = "1.10"

# Async runtime (for future use)
tokio = { version = "1", features = ["full"] }

# Query parsing
sqlparser = "0.60"

# Date/time and regex
chrono = { version = "0.4", default-features = false, features = ["std", "clock"] }
regex = "1"

# Testing
proptest = "1"
criterion = "0.5"

# Metrics and observability
metrics = "0.24"
tracing = "0.1"

# Workspace-wide lints
[workspace.lints.rust]
unsafe_code = "deny"
missing_docs = "warn"

[workspace.lints.clippy]
# Pedantic lints - enable most, allow some that are too noisy
pedantic = { level = "warn", priority = -1 }
module_name_repetitions = "allow"
must_use_candidate = "allow"
missing_errors_doc = "allow"
missing_panics_doc = "allow"
similar_names = "allow"  # Common in database code
doc_markdown = "allow"  # ManifoldDB naming is intentional
redundant_closure = "allow"  # Sometimes more readable
trivially_copy_pass_by_ref = "allow"  # API consistency matters
needless_collect = "allow"  # Sometimes needed for borrow checker
match_same_arms = "allow"  # Intentional grouping for clarity
useless_conversion = "allow"  # API consistency
items_after_statements = "allow"  # Helper functions in tests
float_cmp = "allow"  # Tests sometimes need exact comparison
unnecessary_wraps = "allow"  # Error handling consistency

# Nursery lints - selectively enable
nursery = { level = "warn", priority = -1 }
option_if_let_else = "allow"
redundant_clone = "allow"  # False positives with complex borrows
missing_const_for_fn = "allow"  # Many can't actually be const

# Strict safety lints - library code uses targeted module-level allows
# Test code can use these freely
unwrap_used = "allow"
expect_used = "allow"
panic = "allow"

# Development markers
todo = "warn"
unimplemented = "warn"

# Style
enum_glob_use = "deny"
wildcard_imports = "deny"

# Cast lints - allowed with appropriate bounds checking in code
cast_precision_loss = "allow"
cast_possible_wrap = "allow"
cast_possible_truncation = "allow"
cast_sign_loss = "allow"
cast_lossless = "allow"

# Other allowances for this codebase
too_many_lines = "allow"  # Some functions are necessarily complex
return_self_not_must_use = "allow"  # Builder patterns
unused_self = "allow"  # Future-proofing methods
cognitive_complexity = "allow"  # Query planning is complex
const_is_empty = "allow"  # Compile-time assertions
too_many_arguments = "allow"  # Complex operations need many params
single_match_else = "allow"  # Match is sometimes clearer than if-let
manual_let_else = "allow"  # Style preference
bool_to_int_with_if = "allow"  # Sometimes more explicit
manual_strip = "allow"  # Sometimes more readable
ref_option = "allow"  # API consistency
only_used_in_recursion = "allow"  # Common recursive patterns
use_self = "allow"  # Explicit types can be clearer
needless_continue = "allow"  # Can make logic clearer
significant_drop_tightening = "allow"  # Explicit drop ordering
if_let_mutex = "allow"  # Explicit lock patterns
suboptimal_flops = "allow"  # Readability over micro-optimization
type_complexity = "allow"  # Complex types in query engine
collapsible_match = "allow"  # Explicit match nesting can be clearer
needless_pass_by_value = "allow"  # API design considerations
iter_without_into_iter = "allow"  # Not all types need IntoIterator
uninlined_format_args = "allow"  # Consistent with existing style
map_unwrap_or = "allow"  # Style preference
semicolon_if_nothing_returned = "allow"  # Style preference
deref_addrof = "allow"  # Sometimes needed for clarity
unnecessary_cast = "allow"  # Explicit casts for clarity
useless_vec = "allow"  # Sometimes needed for API compatibility
redundant_closure_for_method_calls = "allow"  # Readability
should_implement_trait = "allow"  # `next` method name conflicts with Iterator
needless_borrow = "allow"  # Sometimes explicit borrows are clearer
match_wildcard_for_single_variants = "allow"  # Explicit exhaustive matching
into_iter_without_iter = "allow"  # Not all types need iter method
needless_range_loop = "allow"  # Index access pattern is clear
approx_constant = "allow"  # Custom constants for specific precision
equatable_if_let = "allow"  # Style preference
bool_assert_comparison = "allow"  # Explicit boolean assertions
no_effect_underscore_binding = "allow"  # Used for side effects
manual_while_let_some = "allow"  # Explicit loop patterns
collection_is_never_read = "allow"  # Setup code in tests
