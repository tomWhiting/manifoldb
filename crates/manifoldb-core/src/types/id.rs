//! Unique identifiers for entities, edges, and collections.
//!
//! This module provides type-safe identifiers for graph nodes ([`EntityId`]),
//! relationships ([`EdgeId`]), and vector collections ([`CollectionId`]).
//!
//! # Example
//!
//! ```
//! use manifoldb_core::types::{EntityId, EdgeId, CollectionId};
//!
//! // Create identifiers
//! let user_id = EntityId::new(1);
//! let edge_id = EdgeId::new(100);
//! let collection_id = CollectionId::new(42);
//!
//! // Convert to raw values for storage/serialization
//! assert_eq!(user_id.as_u64(), 1);
//! assert_eq!(edge_id.as_u64(), 100);
//! assert_eq!(collection_id.as_u64(), 42);
//!
//! // IDs are ordered and hashable
//! let id1 = EntityId::new(1);
//! let id2 = EntityId::new(2);
//! assert!(id1 < id2);
//! ```

use std::fmt;

use serde::{Deserialize, Serialize};

/// Unique identifier for an entity (node) in the graph.
///
/// `EntityId` wraps a `u64` and provides type safety to prevent accidentally
/// using an entity ID where an edge ID is expected (or vice versa).
///
/// IDs are typically auto-generated by the database when creating entities
/// via [`DatabaseTransaction::create_entity`], but can also be created manually
/// for bulk loading scenarios.
///
/// # Example
///
/// ```
/// use manifoldb_core::EntityId;
///
/// let id = EntityId::new(42);
/// assert_eq!(id.as_u64(), 42);
/// println!("{}", id); // Prints: EntityId(42)
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct EntityId(u64);

impl EntityId {
    /// Create a new `EntityId` from a raw u64 value.
    #[inline]
    #[must_use]
    pub const fn new(id: u64) -> Self {
        Self(id)
    }

    /// Get the raw u64 value.
    #[inline]
    #[must_use]
    pub const fn as_u64(self) -> u64 {
        self.0
    }
}

impl From<u64> for EntityId {
    #[inline]
    fn from(id: u64) -> Self {
        Self::new(id)
    }
}

impl fmt::Display for EntityId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "EntityId({})", self.0)
    }
}

/// Unique identifier for an edge (relationship) in the graph.
///
/// `EdgeId` wraps a `u64` and provides type safety to prevent accidentally
/// using an edge ID where an entity ID is expected (or vice versa).
///
/// IDs are typically auto-generated by the database when creating edges
/// via [`DatabaseTransaction::create_edge`], but can also be created manually
/// for bulk loading scenarios.
///
/// # Example
///
/// ```
/// use manifoldb_core::EdgeId;
///
/// let id = EdgeId::new(100);
/// assert_eq!(id.as_u64(), 100);
/// println!("{}", id); // Prints: EdgeId(100)
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct EdgeId(u64);

impl EdgeId {
    /// Create a new `EdgeId` from a raw u64 value.
    #[inline]
    #[must_use]
    pub const fn new(id: u64) -> Self {
        Self(id)
    }

    /// Get the raw u64 value.
    #[inline]
    #[must_use]
    pub const fn as_u64(self) -> u64 {
        self.0
    }
}

impl From<u64> for EdgeId {
    #[inline]
    fn from(id: u64) -> Self {
        Self::new(id)
    }
}

impl fmt::Display for EdgeId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "EdgeId({})", self.0)
    }
}

/// Unique identifier for a point in a vector collection.
///
/// `PointId` wraps a `u64` and provides type safety to prevent accidentally
/// using a point ID where an entity ID or edge ID is expected (or vice versa).
///
/// Points are used in vector collections (similar to Qdrant) where each point
/// has an ID, a payload (JSON-like data), and one or more named vectors.
///
/// # Example
///
/// ```
/// use manifoldb_core::PointId;
///
/// let id = PointId::new(42);
/// assert_eq!(id.as_u64(), 42);
/// println!("{}", id); // Prints: PointId(42)
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct PointId(u64);

impl PointId {
    /// Create a new `PointId` from a raw u64 value.
    #[inline]
    #[must_use]
    pub const fn new(id: u64) -> Self {
        Self(id)
    }

    /// Get the raw u64 value.
    #[inline]
    #[must_use]
    pub const fn as_u64(self) -> u64 {
        self.0
    }
}

impl From<u64> for PointId {
    #[inline]
    fn from(id: u64) -> Self {
        Self::new(id)
    }
}

impl fmt::Display for PointId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "PointId({})", self.0)
    }
}

/// Unique identifier for a collection in the database.
///
/// `CollectionId` wraps a `u64` and provides type safety to prevent accidentally
/// using a collection ID where an entity or edge ID is expected.
///
/// Collections are named containers for entities with associated vector
/// configurations. Each collection defines named vector spaces with their
/// dimensions, distance metrics, and index configurations.
///
/// # Example
///
/// ```
/// use manifoldb_core::CollectionId;
///
/// let id = CollectionId::new(42);
/// assert_eq!(id.as_u64(), 42);
/// println!("{}", id); // Prints: CollectionId(42)
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct CollectionId(u64);

impl CollectionId {
    /// Create a new `CollectionId` from a raw u64 value.
    #[inline]
    #[must_use]
    pub const fn new(id: u64) -> Self {
        Self(id)
    }

    /// Get the raw u64 value.
    #[inline]
    #[must_use]
    pub const fn as_u64(self) -> u64 {
        self.0
    }
}

impl From<u64> for CollectionId {
    #[inline]
    fn from(id: u64) -> Self {
        Self::new(id)
    }
}

impl fmt::Display for CollectionId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "CollectionId({})", self.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn entity_id_roundtrip() {
        let id = EntityId::new(42);
        assert_eq!(id.as_u64(), 42);
    }

    #[test]
    fn edge_id_roundtrip() {
        let id = EdgeId::new(123);
        assert_eq!(id.as_u64(), 123);
    }

    #[test]
    fn point_id_roundtrip() {
        let id = PointId::new(999);
        assert_eq!(id.as_u64(), 999);
    }

    #[test]
    fn ids_are_ordered() {
        let a = EntityId::new(1);
        let b = EntityId::new(2);
        assert!(a < b);

        let p1 = PointId::new(10);
        let p2 = PointId::new(20);
        assert!(p1 < p2);
    }

    #[test]
    fn collection_id_roundtrip() {
        let id = CollectionId::new(42);
        assert_eq!(id.as_u64(), 42);
    }

    #[test]
    fn collection_ids_are_ordered() {
        let a = CollectionId::new(1);
        let b = CollectionId::new(2);
        assert!(a < b);
    }
}
